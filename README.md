[![Coverage Status](https://coveralls.io/repos/github/AnyaAP/labb5/badge.svg?branch=main)](https://coveralls.io/github/AnyaAP/labb5?branch=main)
# lab5
Google Test — это фреймворк от Google для юнит-тестирования кода на С++.\
Google C++ Testing Framework (Google Test) — библиотека для модульного тестирования (англ. unit testing) на языке С++.\
Исходные тексты открыты с середины 2008 года под лицензией BSD. Документация частично переведена на русский язык.

Google Test построена на методологии тестирования xUnit, то есть когда отдельные части программы (классы, функции, модули) проверяются отдельно друг от друга, в изоляции. Библиотека сама по себе разработана с активным применением тестирования, когда при добавлении каких-либо частей в официальную версию, кроме кода самих изменений необходимо написать набор тестов, подтверждающих их корректность. 

### Подключение gtest к проекту

Добавим в CMakeLists.txt строчку
```
find_package(GTest)
```
и изменим строчку target_link_libraries, добавив туда ${GTEST_LIBRARY}, например:

```
target_link_libraries(PROJECT_NAME{GTEST_LIBRARY})
```
В main.cpp делаем
```
#include <gtest/gtest.h>.
```

### Hаписание тестов
Тесты выглядят так:
```
TEST(test_case_name, test_name)
{
    ... test body ...
}
```
test_case_name — имя классa, который мы тестируем, test_name — имя теста внутри этого классa.\

Google Test есть два основных типа проверок (утверждений) ` ASSERT_* и EXPECT_* `.\
Если используется EXPECT_*, то в случае сбоя тест продолжит работу, хотя сбой будет зарегистрирован, 
и тест в любом случае считается неуспешным. Если же продолжение теста бессмысленно, используется ASSERT_*. \
Данная проверка прерывает работу теста в случае несрабатывания проверки. 


### Дополнительные возможности
Библиотека Google Test тесно связана с библиотекой Google Mock, позволяющей тестировать взаимодействие вашего класса с другими.\
С помощью этой библиотеки вы сможете убедиться в том, что ваш класс вызывает методы других объектов, а также проверить, \
что эти методы вызываются с нужными значениями параметров, нужное количество раз, в нужном порядке. \

Предположим, вы пишете фрагмент кода, который должен взаимодействовать с непредсказуемой, дорогостоящей внешней системой (например, веб-сайтом, большой базой данных, физическим датчиком и т. Д.). Ваш код должен продолжать работать, когда время ожидания внешней системы истекает. , или выдает сообщения об ошибках, или предоставляет противоречивые данные. Как вы можете проверить, действительно ли ваш код соответствует этим требованиям?

Что ж, вы можете запускать его с реальным веб-сайтом / базой данных / датчиком / чем-то еще целую кучу раз и надеяться, что вам повезет со всеми ошибками, которые ваш код должен обрабатывать. Очевидно, что это довольно дорогая и ненадежная стратегия тестирования.

Поэтому вместо этого вы пишете что-то, что удовлетворяет тому же интерфейсу, что и веб-сайт / база данных / датчик / что-то еще, но которое вы запрограммировали для выдачи определенных «шаблонных» ответов (ошибки, тайм-ауты, несогласованные данные и т. Д.). Теперь ваши тесты будут работают намного быстрее (потому что они не сталкиваются с накладными расходами реального веб-сайта / базы данных / датчика / чего-то еще), и они предсказуемы. К сожалению, требуется много кода, чтобы написать отдельный «макет» веб-сайта / базы данных / датчика / чего угодно для каждого сценария, который вам нужно протестировать. Чем больше будет работы, тем меньше у вас шансов ее выполнить. Результат: неадекватно протестированный код.\

Gmock и его родственники автоматизируют многие из этих вещей, так что вы можете указать желаемое "стандартное" поведение в середине самого теста за счет всего нескольких строк кода. Если тесты легко написать, вы, вероятно, напишете их больше, и, следовательно, с большей вероятностью обнаружите ошибки перед отправкой кода.\

Кстати, это означает, что вам также нужна «инъекция зависимости»: ваш код должен принимать параметр типа интерфейса, и вы должны иметь возможность передавать либо фиктивный объект (для модульного тестирования), либо «настоящий» Веб-сайт / база данных / датчик / что угодно (для реального использования).\

